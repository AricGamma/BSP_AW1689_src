/** @file
*
*  Copyright (c) 2007-2016, Allwinner Technology Co., Ltd. All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
**/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, SileadTouchCreateDevice)
#endif


NTSTATUS
SileadTouchCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_OBJECT_ATTRIBUTES   deviceAttributes;
    WDF_OBJECT_ATTRIBUTES   attributes;
    PDEVICE_EXTENSION	devContext;
    WDFDEVICE device;
    NTSTATUS status;
    WDF_PNPPOWER_EVENT_CALLBACKS  pnpPowerCallbacks;
    WDF_INTERRUPT_CONFIG InterruptConfiguration;
    WDFINTERRUPT WdfInterrupt;
    WDF_IO_QUEUE_CONFIG	queueConfig;
	
#ifdef GSL_TIMER
	HANDLE  thread_handle;
#endif
    PAGED_CODE();
	
    //DbgPrintEx(DPFLTR_IHVDRIVER_ID,0,"SSSSSSSSSSSSSSSSSSSS SileadTouchCreateDevice entry\n");

	WdfDeviceInitSetPowerPolicyOwnership(DeviceInit, FALSE);

   // WdfFdoInitSetFilter(DeviceInit);
	
    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
    pnpPowerCallbacks.EvtDevicePrepareHardware = HidGSLEvtDevicePrepareHardware;
    pnpPowerCallbacks.EvtDeviceReleaseHardware = HidGSLEvtDeviceReleaseHardware;
    pnpPowerCallbacks.EvtDeviceD0Entry = HidGSLEvtDeviceD0Entry;
    pnpPowerCallbacks.EvtDeviceD0Exit = HidGSLEvtDeviceD0Exit;
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);
	
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_EXTENSION);
    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status)) {
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        devContext= GetDeviceContext(device);
        //
        // Initialize the context.
        //
        devContext->DpcInProgress = FALSE;
        devContext->DpcRerun = FALSE;
		devContext->bStartTime = FALSE;
        devContext->ScanTime = 0;
		devContext->NoIDVersion = TRUE;		
#ifdef SUPPORT_WINKEY
		devContext->ButtonDown = FALSE;
#endif
		{
			UINT8 i = 0;
			UINT8 j = 0;
			for (; i < PS_DEEP; i++)
			{
				for (; j < MAX_CONTACTS; j++)
				{
					devContext->Point_Data[i][j].id = 0;
					devContext->Point_Data[i][j].x = 0;
					devContext->Point_Data[i][j].y = 0;
				}
				devContext->ContactCount[i] = 0;
			}
		}
#ifdef GSL_TIMER
	//
	// Initialize the timer.
	//
	KeInitializeEvent(&devContext->request_event,
		NotificationEvent,
		FALSE);

	devContext->int_1st[0] = 0;
	devContext->int_1st[1] = 0;
	devContext->int_1st[2] = 0;
	devContext->int_1st[3] = 0;
	devContext->int_2nd[0] = 0;
	devContext->int_2nd[1] = 0;
	devContext->int_2nd[2] = 0;
	devContext->int_2nd[3] = 0;
	devContext->b0_counter = 0;
	devContext->bc_counter = 0;
	devContext->i2c_lock = 0;
	KeInitializeDpc(&devContext->EsdDPC, GSLDevESDRoutine, (PVOID)devContext);
	KeInitializeTimerEx(&devContext->EsdTimer, NotificationTimer);
	devContext->terminate_thread = FALSE;

	status = PsCreateSystemThread(
		&thread_handle,
		(ACCESS_MASK)0L,
		NULL,
		NULL,
		NULL,
		ThreadFunc,
		(PVOID)devContext
		);

	if (!NT_SUCCESS(status))
	{
		return status;
	}

	status = ObReferenceObjectByHandle(
		thread_handle,
		THREAD_ALL_ACCESS,
		NULL,
		KernelMode,
		&devContext->thread_pointer,
		NULL
		);

	if (!NT_SUCCESS(status))
	{
		ZwClose(thread_handle);
		devContext->terminate_thread = TRUE;

		KeSetEvent(
			&devContext->request_event,
			(KPRIORITY)0,
			FALSE
			);
		return status;
	}

	ZwClose(thread_handle);

#endif
        //
        // Initialize the interrupt.
        //
        WDF_INTERRUPT_CONFIG_INIT(&InterruptConfiguration,
            GSLDevInterruptIsr,
            GSLDevInterruptDpc);
        InterruptConfiguration.PassiveHandling = TRUE;
        status = WdfInterruptCreate(device,
            &InterruptConfiguration,
            WDF_NO_OBJECT_ATTRIBUTES,
            &WdfInterrupt);
        if (!NT_SUCCESS(status)) {
            DbgPrint("WdfInterruptCreate failed 0x%x\n", status);
            return status;
        }
		
        //
        // Initialize the I/O Package and any Queues
        //
        WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&queueConfig, WdfIoQueueDispatchParallel);
        queueConfig.EvtIoInternalDeviceControl = HidGSLEvtInternalDeviceControl;
        queueConfig.PowerManaged = WdfFalse;
        status = WdfIoQueueCreate(device,
            &queueConfig,
            WDF_NO_OBJECT_ATTRIBUTES,
			&devContext->IoctlQueue
        );
        if (!NT_SUCCESS(status)) {
            DbgPrint("WdfIoQueueCreate Default Queue failed 0x%x\n", status);
            return status;
        }

        //ReportQueue
        WDF_IO_QUEUE_CONFIG_INIT(&queueConfig, WdfIoQueueDispatchManual);
        queueConfig.PowerManaged = WdfFalse;
        status = WdfIoQueueCreate(device,
            &queueConfig,
            WDF_NO_OBJECT_ATTRIBUTES,
            &devContext->ReportQueue
        );
        if (!NT_SUCCESS(status)) {
            DbgPrint("WdfIoQueueCreate ReportQueue failed 0x%x\n", status);
            return status;
        }
        
        //CompletionQueue
        WDF_IO_QUEUE_CONFIG_INIT(&queueConfig, WdfIoQueueDispatchManual);
        queueConfig.PowerManaged = WdfFalse;
        WdfIoQueueCreate(device,
            &queueConfig,
            WDF_NO_OBJECT_ATTRIBUTES,
            &devContext->CompletionQueue);
        if (!NT_SUCCESS(status)) {
            DbgPrint("WdfIoQueueCreate CompletionQueue failed 0x%x\n", status);
            return status;
        }

        // idle queue
        WDF_IO_QUEUE_CONFIG_INIT(&queueConfig, WdfIoQueueDispatchManual);
        queueConfig.PowerManaged = WdfFalse;
        WdfIoQueueCreate(device,
            &queueConfig,
            WDF_NO_OBJECT_ATTRIBUTES,
            &devContext->IdleQueue);
        if (!NT_SUCCESS(status)) {
            DbgPrint("WdfIoQueueCreate IdleQueue failed 0x%x\n", status);
            return status;
        }
        //DpcLock
        WDF_OBJECT_ATTRIBUTES_INIT(&attributes);
        attributes.ParentObject = device;
        status = WdfSpinLockCreate(
            &attributes,
            &devContext->DpcLock
            );
        if (!NT_SUCCESS(status)) {
            DbgPrint("WdfSpinLockCreate DpcLock failed 0x%x\n", status);
            return status;
        }
    }
	//DbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "SSSSSSSSSSSSSSSSSSSS SileadTouchCreateDevice exit\n");
    DbgPrint("SileadTouchCreateDevice Exit\n");
    return status;
}


